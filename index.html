<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>真·以气御剑 (摄像头版)</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #00ffff;
            font-family: 'KaiTi', serif;
            font-size: 24px;
            text-shadow: 0 0 10px #00ffff;
            pointer-events: none;
            z-index: 10;
        }
        /* 摄像头预览窗口 */
        #webcam-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 240px;
            height: 180px;
            border: 2px solid #00ffff;
            border-radius: 10px;
            overflow: hidden;
            z-index: 20;
            background: rgba(0,0,0,0.5);
            transform: scaleX(-1); /* 镜像翻转，让操作更直观 */
        }
        #input_video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 30px;
            font-family: sans-serif;
            text-shadow: 0 0 20px #00ffff;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="loading">正在连接灵界 (加载摄像头)...</div>
    <div id="info">伸出食指控制方向 | 拇指食指捏合加速<br><span style="font-size:16px; opacity:0.7">剑随心动</span></div>
    
    <div id="webcam-container">
        <video id="input_video"></video>
    </div>

    <script>
        // ================= Three.js 场景部分 (飞剑逻辑) =================
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000510, 0.002);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 20;
        camera.position.y = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // 创建飞剑
        const swordGroup = new THREE.Group();
        const bladeGeo = new THREE.ConeGeometry(0.5, 8, 4);
        const bladeMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const blade = new THREE.Mesh(bladeGeo, bladeMat);
        blade.rotation.x = Math.PI / 2;
        blade.rotation.y = Math.PI / 4;
        swordGroup.add(blade);

        const handleGeo = new THREE.CylinderGeometry(0.2, 0.2, 2, 8);
        const handleMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const handle = new THREE.Mesh(handleGeo, handleMat);
        handle.rotation.x = Math.PI / 2;
        handle.position.z = 5;
        swordGroup.add(handle);

        const guardGeo = new THREE.BoxGeometry(2, 0.2, 0.5);
        const guardMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 1, roughness: 0.2 });
        const guard = new THREE.Mesh(guardGeo, guardMat);
        guard.position.z = 4;
        swordGroup.add(guard);

        scene.add(swordGroup);

        // 粒子系统
        const cloudsGeo = new THREE.BufferGeometry();
        const cloudCount = 1000;
        const posArray = new Float32Array(cloudCount * 3);
        for(let i=0; i < cloudCount * 3; i+=3) {
            posArray[i] = (Math.random() - 0.5) * 200;
            posArray[i+1] = (Math.random() - 0.5) * 100;
            posArray[i+2] = (Math.random() - 0.5) * 400 - 100;
        }
        cloudsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const cloudMat = new THREE.PointsMaterial({ size: 0.5, color: 0xffffff, transparent: true, opacity: 0.6 });
        const starField = new THREE.Points(cloudsGeo, cloudMat);
        scene.add(starField);

        // 灯光与后期
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(0, 10, 5);
        scene.add(dirLight);
        const swordLight = new THREE.PointLight(0x00ffff, 2, 20);
        swordGroup.add(swordLight);

        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(new THREE.RenderPass(scene, camera));
        composer.addPass(new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85));

        // ================= AI 手部识别逻辑 (MediaPipe) =================
        const videoElement = document.getElementById('input_video');
        let handX = 0; // 手指的X位置 (-1 到 1)
        let handY = 0; // 手指的Y位置 (-1 到 1)
        let isPinching = false; // 是否捏合加速

        function onResults(results) {
            document.getElementById('loading').style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. 获取食指指尖 (Index Finger Tip - 索引 8)
                const indexFinger = landmarks[8];
                const thumbFinger = landmarks[4];

                // 2. 映射坐标 (摄像头坐标是 0~1，我们需要映射到屏幕范围)
                // 注意：摄像头是镜像的，所以 X 要反转
                handX = (1 - indexFinger.x) * 2 - 1; // 映射到 -1 ~ 1
                handY = -(indexFinger.y * 2 - 1);    // Y轴反转，映射到 -1 ~ 1

                // 3. 计算食指和拇指的距离 (判断是否捏合)
                const distance = Math.sqrt(
                    Math.pow(indexFinger.x - thumbFinger.x, 2) + 
                    Math.pow(indexFinger.y - thumbFinger.y, 2)
                );

                // 如果距离小于 0.05，认为是捏合手势
                isPinching = distance < 0.05;
                
                // 视觉反馈：如果捏合，飞剑光芒变红
                if(isPinching) {
                    bladeMat.color.setHex(0xff0000); // 红色暴走模式
                    swordLight.color.setHex(0xff0000);
                } else {
                    bladeMat.color.setHex(0x00ffff); // 青色正常模式
                    swordLight.color.setHex(0x00ffff);
                }
            }
        }

        const hands = new Hands({
